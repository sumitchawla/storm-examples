package storm.example;

import backtype.storm.Config;
import backtype.storm.LocalCluster;
import backtype.storm.LocalDRPC;
import backtype.storm.generated.Grouping;
import backtype.storm.spout.SpoutOutputCollector;
import backtype.storm.task.IMetricsContext;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseRichSpout;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Values;
import backtype.storm.utils.Utils;
import org.apache.log4j.Logger;
import storm.trident.TridentState;
import storm.trident.TridentTopology;
import storm.trident.operation.BaseAggregator;
import storm.trident.operation.BaseFunction;
import storm.trident.operation.TridentCollector;
import storm.trident.operation.builtin.FilterNull;
import storm.trident.spout.IBatchSpout;
import storm.trident.state.BaseQueryFunction;
import storm.trident.state.BaseStateUpdater;
import storm.trident.state.State;
import storm.trident.state.StateFactory;
import storm.trident.tuple.TridentTuple;

import java.util.*;

/**
 * Created by sumitc on 4/29/15.
 */
public class TridentStateExample  {

    public enum PartyName {
        Democratic,
        Republican,
    }

    //RandomVoteSpout keeps emitting batches of 100 random votes
    // in that constituency. Each batch has  random number of votes
    // for either parties. So results are unpredictable :)
    public static class RandomVoteSpout implements IBatchSpout {
        Random _rand;
        Integer _constituencyId;

        public void open(Map conf, TopologyContext context,
                         SpoutOutputCollector collector) {
        }

        public void open(Map map, TopologyContext topologyContext) {
            _rand = new Random();
            _constituencyId = topologyContext.getThisTaskIndex();
        }

        public void emitBatch(long batchId, TridentCollector collector) {
            Utils.sleep(1000);
            //Wait for 1 sec, and then emit a new batch of
            // 100 random votes for this constituency.
            for(Integer count = 0; count< 100; count++){
                PartyName[] partyNames = PartyName.values();
                collector.emit(new Values(this._constituencyId,
                        partyNames[_rand.nextInt(partyNames.length)]
                                .toString()));
            }
        }

        public void ack(long l) {
        }

        public void close() {
        }

        public Map getComponentConfiguration() {
            return null;
        }

        public Fields getOutputFields() {
            return new Fields("ConstituencyId", "PartyName");
        }
    }

    public static class ConstituencyState {
       Long DemocratsVotes = 0L;
       Long RepublicanVotes = 0L;
    }


    //VoteCountAggregator handles all votes coming
    // for a particular constituency.
    public static class VoteCountAggregator
            extends BaseAggregator<VoteCountAggregator.CountState> {
        private static final Logger LOG =
                Logger.getLogger(VoteCountAggregator.class);
        private Object _batchId;
        static class CountState {
            Integer constituencyId;
            ConstituencyState state = new ConstituencyState();
        }

        public CountState init(Object batchId,
                               TridentCollector collector) {
            this._batchId = batchId;
            CountState state = new CountState();
            return state;
        }

        // Aggregate function will be called for
        // each vote generated by a Constituency
        // in a particular batch
        public void aggregate(CountState state,
                              TridentTuple tuple,
                              TridentCollector collector) {
            Integer constituencyId =
                    tuple.getIntegerByField("ConstituencyId");
            state.constituencyId = constituencyId;
            PartyName partyName =
                    PartyName.valueOf(
                            tuple.getStringByField("PartyName"));
            LOG.debug(String.format("Got tuple %s %s %s",
                    constituencyId, partyName,
                    state.state.DemocratsVotes));
            if (partyName == PartyName.Democratic) {
                state.state.DemocratsVotes++;
            } else if (partyName == partyName.Republican) {
                state.state.RepublicanVotes++;
            }
        }

        // complete is called as soon as all
        // the votes in the particular batch are processed.
        public void complete(CountState state,
                             TridentCollector collector) {
            LOG.debug(String.format("%s Emitting counts " +
                            "for Constituency %d" +
                            " - Democracts %d " +
                            "Republican %d for Batch %s",
                    hashCode(),
                    state.constituencyId,
                    state.state.DemocratsVotes,
                    state.state.RepublicanVotes,
                    _batchId));
            collector.emit(new Values(state.constituencyId, state.state));
        }
    }

    //Handles incoming aggregators from each batch,
    // and updates the uber Election state
    public static class StateUpdater
            extends BaseStateUpdater<ElectionState> {
        public void updateState(ElectionState state,
                                List<TridentTuple> tuples,
                                TridentCollector collector) {
            List<Integer> ids = new ArrayList<Integer>();
            List<ConstituencyState> states = new ArrayList<ConstituencyState>();
            for(TridentTuple t: tuples) {
                ids.add(t.getInteger(0));
                states.add((ConstituencyState) t.get(1));
            }
            state.setStateValues(ids, states);
        }
    }




    public static class StateUpdaterFactory
            implements StateFactory {
        static ElectionState electionState = new ElectionState();
        public storm.trident.state.State
            makeState(Map conf, IMetricsContext metricsContext,
                      int partitionIndex, int numPartitions) {
            return electionState;
        }
    }

    public static class ElectionState implements State {
        private static final Logger LOG =
                Logger.getLogger(ElectionState.class);

        private final Map<Integer, ConstituencyState> totalCount;

        public ElectionState() {
            totalCount = new HashMap<Integer, ConstituencyState>();
        }


        public void setStateValues(List<Integer> constituencyList,
                                   List<ConstituencyState> batchStates) {
            for(int i=0; i<constituencyList.size(); i++) {
                Integer constituencyId = constituencyList.get(i);
                ConstituencyState batchUpdateForConstituency =
                        batchStates.get(i);
                if (!totalCount.containsKey(constituencyId)){
                    totalCount.put(constituencyId,
                            new ConstituencyState());
                }

                ConstituencyState totalCountsForConstituency =
                        totalCount.get(constituencyId);
                totalCountsForConstituency.DemocratsVotes +=
                        batchUpdateForConstituency.DemocratsVotes;
                totalCountsForConstituency.RepublicanVotes+=
                        batchUpdateForConstituency.RepublicanVotes;
                LOG.debug(String.format("%s - Commited counts for " +
                                "Constituency %d - Current Counts - " +
                                "Democrats %d Republican %d ",
                        hashCode(),
                        constituencyId,
                        totalCountsForConstituency.DemocratsVotes,
                        totalCountsForConstituency.RepublicanVotes));
            }
        }

        public List<ConstituencyState>
            getCurrentCountsForConstituency(
                List<Integer> constituencyList) {
            List<ConstituencyState> states =
                    new ArrayList<ConstituencyState>();
            for(int i=0; i<constituencyList.size(); i++) {
                Integer constituencyId = constituencyList.get(i);
                LOG.debug(String.format("GET for %d %d %s", constituencyId, totalCount.size(), hashCode()));
                if (totalCount.containsKey(constituencyId)) {
                    states.add(totalCount.get(constituencyId));
                } else {
                    states.add(new ConstituencyState());
                }
            }
            return states;
        }

        public List<ConstituencyState> getAllCounts() {
            return new ArrayList<ConstituencyState>(
                    totalCount.values());
        }

        public void beginCommit(Long aLong) {

        }

        public void commit(Long aLong) {

        }
    }


    public static class QueryConstituencyLeader
            extends BaseQueryFunction<ElectionState, Object> {
        public List<Object> batchRetrieve(
                ElectionState state,
                List<TridentTuple> inputs) {
            List<Integer> ids =
                    new ArrayList<Integer>();
            List<Object> result =
                    new ArrayList<Object>();
            for(TridentTuple input: inputs) {
                ids.add(Integer.valueOf(input.getString(0)));
            }
            List<ConstituencyState> currentStates =
                    state.getCurrentCountsForConstituency(ids);
            for(ConstituencyState constituencyState :
                    currentStates ) {
                if (constituencyState.DemocratsVotes
                        > constituencyState.RepublicanVotes) {
                    result.add(PartyName.Democratic);
                } else {
                    result.add(PartyName.Republican);
                }
            }
            return result;
        }

        public void execute(TridentTuple tuple,
                            Object result,
                            TridentCollector collector) {
            collector.emit(new Values(result));
        }
    }

    public static class QueryConstituencyCount
            extends BaseQueryFunction<ElectionState, Object> {
        public List<Object> batchRetrieve(
                ElectionState state,
                List<TridentTuple> inputs) {
            List<Integer> ids =
                    new ArrayList<Integer>();
            List<Object> result =
                    new ArrayList<Object>();
            for(TridentTuple input: inputs) {
                ids.add(Integer.valueOf(input.getString(0)));
            }
            List<ConstituencyState> currentStates =
                    state.getCurrentCountsForConstituency(ids);
            for(ConstituencyState constituencyState :
                    currentStates ) {
                HashMap<String,Long> counts =
                        new HashMap<String, Long>();
                counts.put(PartyName.Democratic.toString(),
                        constituencyState.DemocratsVotes);
                counts.put(PartyName.Republican.toString(),
                        constituencyState.RepublicanVotes);
                result.add(counts);
            }
            return result;
        }

        public void execute(TridentTuple tuple,
                            Object result,
                            TridentCollector collector) {
            collector.emit(new Values(result));
        }
    }

    public static class QueryElectionLeader
            extends BaseQueryFunction<ElectionState, Object> {
        public List<Object> batchRetrieve(
                ElectionState state,
                List<TridentTuple> inputs) {
            List<Integer> ids =
                    new ArrayList<Integer>();
            List<Object> result =
                    new ArrayList<Object>();
            List<ConstituencyState> currentStates =
                    state.getAllCounts();
            Long democratsLeadingCount = 0L;
            Long republicansLeadingCount = 0L;
            for(ConstituencyState constituencyState :
                    currentStates ) {
                if (constituencyState.DemocratsVotes >
                        constituencyState.RepublicanVotes) {
                    democratsLeadingCount++;
                } else {
                    republicansLeadingCount++;
                }
            }
            Map<String, Long> map = new HashMap<String, Long>();
            map.put(PartyName.Democratic.toString(),
                    democratsLeadingCount);
            map.put(PartyName.Republican.toString(),
                    republicansLeadingCount);
            result.add(map);
            return result;
        }

        public void execute(TridentTuple tuple, Object result, TridentCollector collector) {
            collector.emit(new Values(result));
        }
    }

    public static void main(String[] args) {
        TridentTopology topology = new TridentTopology();

        Grouping partitonGroup = new Grouping();
        List<String> fields = new ArrayList<String>();
        fields.add("ConstituencyId");
        partitonGroup.set_fields(fields);

        TridentState loginCounts =
                         topology.newStream("voting-events", new RandomVoteSpout())
                        //Lets call this stream the VoteStream
                        .name("VoteStream")
                        //Each spout will act like a different constituency.
                        //For this election we will have 100 constituencies.
                        .parallelismHint(100)
                        //Votes generated by a particular constituency
                        // should go to a same count aggregator.
                        .partition(partitonGroup)
                        //VoteCountAggregator handles batches of votes.
                        // Its does a very simple of aggregation.
                        // Maintains a separate count for each party
                        //PartyName, and ConstituencyId are the keys for partitioning
                        // to the VoteCountAggregator, and ConstituencyId, count is the
                        // output of the aggregator
                        .partitionAggregate(new Fields("ConstituencyId", "PartyName"),
                             new VoteCountAggregator(),
                             new Fields("ConstituencyId", "count"))
                             .name("CountAggregator")
                        //Lets have 10 centers doing VoteCountAggregator for
                        // 100 constituency.
                        // On Average each aggregator handles 10 constituencies
                        .parallelismHint(10)
                        //Finally we have a Single Authority maintaining
                        //overall state of the election.
                        .partitionPersist(new StateUpdaterFactory(),
                                new Fields("ConstituencyId", "count"),
                                new StateUpdater());

        LocalDRPC drpc = new LocalDRPC();

        topology.newDRPCStream("vote-count", drpc)
                .stateQuery(loginCounts, new Fields("args"), new QueryConstituencyCount(), new Fields("count"))
                .each(new Fields("count"), new FilterNull());

        topology.newDRPCStream("leader", drpc)
                .stateQuery(loginCounts, new Fields("args"), new QueryElectionLeader(), new Fields("count"))
                .each(new Fields("count"), new FilterNull());

        LocalCluster cluster = new LocalCluster();


        Config conf = new Config();
        cluster.submitTopology("trident", conf,
                topology.build());

        for (int i = 0; i < 1000; i++) {
            System.out.println(String.format("Current Counts for Constituency %s", drpc.execute("vote-count", "1")));
            System.out.println(String.format("Current Election Counts %s", drpc.execute("leader", "")));
            Utils.sleep(2000);
        }
        cluster.shutdown();
        drpc.shutdown();
    }
}
